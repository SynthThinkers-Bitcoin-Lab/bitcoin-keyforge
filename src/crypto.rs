use anyhow::Result;
use base58::ToBase58;
use secp256k1::{PublicKey, Secp256k1, SecretKey};
use sha2::{Digest, Sha256};
use std::str::FromStr;
use rand::rngs::OsRng;

pub fn generate_keypair() -> Result<(String, String)> {
    let secp = Secp256k1::new();
    let mut rng = OsRng;

    let secret_key = SecretKey::new(&mut rng);
    let public_key = PublicKey::from_secret_key(&secp, &secret_key);

    let private_key_hex = hex::encode(secret_key.secret_bytes());
    let public_key_hex = hex::encode(public_key.serialize());

    Ok((private_key_hex, public_key_hex))
}

pub fn private_key_to_public_key(private_key_hex: &str) -> Result<String> {
    let secp = Secp256k1::new();
    let secret_key = SecretKey::from_str(private_key_hex)?;
    let public_key = PublicKey::from_secret_key(&secp, &secret_key);

    Ok(hex::encode(public_key.serialize()))
}

/// Combine master private key with auxiliary private keys
///
/// This function takes a master private key and one or more auxiliary private keys
/// (provided by the user) and combines them using secp256k1 elliptic curve addition
/// to create a new combined private key that produces the desired Bitcoin address.
///
/// # Arguments
/// * `master_key` - The main private key (generated by this tool)
/// * `auxiliary_keys` - User-provided auxiliary private keys to combine with master
///
/// # Returns
/// Combined private key as hex string
pub fn combine_private_keys(master_key: &str, auxiliary_keys: &[String]) -> Result<String> {
    if auxiliary_keys.is_empty() {
        anyhow::bail!("Cannot combine master key with empty list of auxiliary keys");
    }

    let mut combined = SecretKey::from_str(master_key)?;

    for auxiliary_key_hex in auxiliary_keys {
        let auxiliary_key = SecretKey::from_str(auxiliary_key_hex)?;
        combined = combined.add_tweak(&auxiliary_key.into())?;
    }

    Ok(hex::encode(combined.secret_bytes()))
}

pub fn private_key_to_wif(private_key_hex: &str, testnet: bool) -> Result<String> {
    let key_bytes = hex::decode(private_key_hex)?;
    if key_bytes.len() != 32 {
        anyhow::bail!("Private key must be 32 bytes");
    }

    // Version byte: 0x80 for mainnet, 0xEF for testnet
    let version_byte = if testnet { 0xEF } else { 0x80 };

    // Create extended key with version byte + private key + compression flag (0x01)
    let mut extended_key = Vec::with_capacity(34);
    extended_key.push(version_byte);
    extended_key.extend_from_slice(&key_bytes);
    extended_key.push(0x01); // Compression flag for compressed public key

    // Double SHA256 for checksum
    let hash1 = Sha256::digest(&extended_key);
    let hash2 = Sha256::digest(hash1);
    let checksum = &hash2[0..4];

    // Append checksum
    extended_key.extend_from_slice(checksum);

    // Base58 encode
    Ok(extended_key.to_base58())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_keypair_generation() {
        let result = generate_keypair();
        assert!(result.is_ok());

        let (private_key, public_key) = result.unwrap();
        assert_eq!(private_key.len(), 64);
        assert_eq!(public_key.len(), 66);
    }

    #[test]
    fn test_private_to_public_conversion() {
        let (private_key, expected_public) = generate_keypair().unwrap();
        let derived_public = private_key_to_public_key(&private_key).unwrap();
        assert_eq!(expected_public, derived_public);
    }

    #[test]
    fn test_key_combination() {
        let master_key = "1111111111111111111111111111111111111111111111111111111111111111";
        let auxiliary_keys = vec![
            "2222222222222222222222222222222222222222222222222222222222222222".to_string(),
        ];

        let result = combine_private_keys(master_key, &auxiliary_keys);
        assert!(result.is_ok());
    }

    #[test]
    fn test_wif_encoding() {
        let private_key = "1111111111111111111111111111111111111111111111111111111111111111";

        // Test mainnet WIF
        let mainnet_wif = private_key_to_wif(private_key, false).unwrap();
        assert!(mainnet_wif.starts_with('K') || mainnet_wif.starts_with('L'));

        // Test testnet WIF
        let testnet_wif = private_key_to_wif(private_key, true).unwrap();
        assert!(testnet_wif.starts_with('c') || testnet_wif.starts_with('9'));

        // Ensure different networks produce different WIFs
        assert_ne!(mainnet_wif, testnet_wif);
    }

    #[test]
    fn test_key_combination_with_multiple_auxiliary() {
        let master_key = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";
        let auxiliary_keys = vec![
            "1111111111111111111111111111111111111111111111111111111111111111".to_string(),
            "2222222222222222222222222222222222222222222222222222222222222222".to_string(),
        ];

        let result = combine_private_keys(master_key, &auxiliary_keys);
        assert!(result.is_ok());

        // The combined key should be different from the master key
        let combined_key = result.unwrap();
        assert_ne!(combined_key, master_key);
    }

    #[test]
    fn test_combination_validation() {
        let master_key = "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef";

        // Test empty auxiliary keys
        assert!(combine_private_keys(master_key, &[]).is_err());

        // Test invalid auxiliary key length
        let invalid_auxiliary = vec!["short".to_string()];
        assert!(combine_private_keys(master_key, &invalid_auxiliary).is_err());
    }
}
